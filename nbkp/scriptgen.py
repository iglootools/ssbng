"""Generate a standalone bash script from nbkp config.

Compiles a Config into a self-contained shell script that performs
the same sync operations as ``nbkp run``, with all paths and
options baked in.  The generated script accepts ``--dry-run``
and ``--verbose`` flags at runtime.
"""

from __future__ import annotations

import os
import shlex
from dataclasses import dataclass
from datetime import datetime, timezone

from .config import (
    Config,
    LocalVolume,
    RemoteVolume,
    RsyncServer,
    SyncConfig,
)
from .remote.ssh import build_ssh_base_args
from .sync.rsync import build_rsync_command

_SH_INDENT = "    "


@dataclass(frozen=True)
class ScriptOptions:
    """Options for script generation."""

    config_path: str | None = None
    output_file: str | None = None
    relative_src: bool = False
    relative_dst: bool = False


def _build_vol_paths(
    config: Config,
    options: ScriptOptions,
) -> dict[str, str]:
    """Compute volume slug -> effective path (absolute or relative).

    Local volumes are relativized when they appear as source
    (and ``relative_src`` is set) or as destination (and
    ``relative_dst`` is set).  Remote volumes always keep their
    absolute path.
    """
    src_slugs = {s.source.volume for s in config.syncs.values()}
    dst_slugs = {s.destination.volume for s in config.syncs.values()}

    vol_paths: dict[str, str] = {}
    for slug, vol in config.volumes.items():
        match vol:
            case RemoteVolume():
                vol_paths[slug] = vol.path
            case LocalVolume():
                should_relativize = (
                    slug in src_slugs and options.relative_src
                ) or (slug in dst_slugs and options.relative_dst)
                if should_relativize and options.output_file:
                    output_dir = os.path.dirname(options.output_file)
                    rel = os.path.relpath(vol.path, output_dir)
                    vol_paths[slug] = f"${{NBKP_SCRIPT_DIR}}/{rel}"
                else:
                    vol_paths[slug] = vol.path
    return vol_paths


def _vol_path(
    vol_paths: dict[str, str],
    slug: str,
    subdir: str | None = None,
) -> str:
    """Resolve full path from the vol_paths mapping."""
    base = vol_paths[slug]
    if subdir:
        return f"{base}/{subdir}"
    return base


def _substitute_vol_path(
    arg: str,
    vol: LocalVolume | RemoteVolume,
    vol_paths: dict[str, str],
    slug: str,
) -> str:
    """Replace the absolute volume path prefix in *arg* with vol_paths."""
    match vol:
        case RemoteVolume():
            return arg
        case LocalVolume():
            return arg.replace(vol.path, vol_paths[slug], 1)


def generate_script(
    config: Config,
    options: ScriptOptions,
    *,
    now: datetime | None = None,
) -> str:
    """Generate a standalone bash script from config."""
    if now is None:
        now = datetime.now(timezone.utc)
    vol_paths = _build_vol_paths(config, options)
    parts = [
        _generate_header(options, now, vol_paths),
        _generate_volume_checks(config, vol_paths),
        _generate_sync_functions(config, vol_paths),
        _generate_invocations(config),
        _generate_summary(),
    ]
    return "\n".join(parts) + "\n"


# -- Header --------------------------------------------------------


def _generate_header(
    options: ScriptOptions,
    now: datetime,
    vol_paths: dict[str, str],
) -> str:
    timestamp = now.isoformat(timespec="seconds").replace("+00:00", "Z")
    config_line = (
        f"# Config: {options.config_path}"
        if options.config_path
        else "# Config: <stdin>"
    )
    has_relative = any("$" in p for p in vol_paths.values())
    script_dir_line = (
        "\nNBKP_SCRIPT_DIR=" '"$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"'
        if has_relative
        else ""
    )
    return f"""\
#!/bin/bash
# Generated by nbkp sh — {timestamp}
{config_line}
#
# Preserved from nbkp run:
#   - All 4 rsync command variants \
(local→local, local→remote, remote→local, remote→remote)
#   - SSH options (port, key, -o options, proxy jump -J)
#   - Rsync filters and filter-file support
#   - Btrfs: snapshot creation, link-dest incremental backups, \
pruning
#   - Pre-flight checks: volume markers (.nbkp-vol), \
endpoint markers (.nbkp-src/.nbkp-dst)
#   - Dry-run and verbose support (as runtime script arguments)
#   - Nonzero exit on any sync failure
#
# Dropped from nbkp run:
#   - Rich console output (spinners, tables, progress bars) \
→ simple log messages
#   - JSON output mode → not applicable for a shell script
#   - Python runtime / config parsing → all values hardcoded
#   - allow-removable-devices flag \
→ checks are inline, comment out if not needed
#   - Paramiko-only SSH options \
(channel_timeout, disabled_algorithms) → no ssh CLI equivalent

# Unofficial bash strict mode \
(http://redsymbol.net/articles/unofficial-bash-strict-mode/)
set -euo pipefail
IFS=$'\\n\\t'{script_dir_line}

NBKP_DRY_RUN=false
NBKP_VERBOSE=0

# --- Argument parsing ---
while [ $# -gt 0 ]; do
  case "$1" in
    -n|--dry-run) NBKP_DRY_RUN=true; shift;;
    -v) NBKP_VERBOSE=$((NBKP_VERBOSE + 1)); shift;;
    --verbose) NBKP_VERBOSE=$((NBKP_VERBOSE + 1)); shift;;
    *) echo "Unknown option: $1" >&2; exit 1;;
  esac
done

NBKP_FAILURES=0
nbkp_log() {{ echo "[nbkp] $*" >&2; }}"""


# -- Volume checks -------------------------------------------------


def _generate_volume_checks(
    config: Config,
    vol_paths: dict[str, str],
) -> str:
    lines = ["", "# --- Volume checks ---"]
    for slug, vol in config.volumes.items():
        vpath = vol_paths[slug]
        marker = f"{vpath}/.nbkp-vol"
        match vol:
            case LocalVolume():
                lines.append(
                    f"test -f {_qp(marker)}"
                    f" || {{ nbkp_log"
                    f' "WARN: volume {slug}:'
                    f' marker {marker} not found";'
                    f" }}"
                )
            case RemoteVolume():
                server = config.rsync_servers[vol.rsync_server]
                proxy = config.resolve_proxy(server)
                ssh_check = _format_remote_test(server, proxy, ["-f", marker])
                lines.append(
                    f"{ssh_check}"
                    f" || {{ nbkp_log"
                    f' "WARN: volume {slug}:'
                    f' marker {marker} not found";'
                    f" }}"
                )
    return "\n".join(lines)


# -- Sync functions ------------------------------------------------


def _generate_sync_functions(
    config: Config,
    vol_paths: dict[str, str],
) -> str:
    parts = ["", "# --- Sync functions ---"]
    for slug, sync in config.syncs.items():
        if sync.enabled:
            parts.append(
                _generate_sync_function(slug, sync, config, vol_paths)
            )
        else:
            parts.append(
                _generate_disabled_sync(slug, sync, config, vol_paths)
            )
    return "\n".join(parts)


def _generate_sync_function(
    slug: str,
    sync: SyncConfig,
    config: Config,
    vol_paths: dict[str, str],
) -> str:
    i1 = _SH_INDENT
    fn_name = _slug_to_fn(slug)
    lines = [
        "",
        f"{fn_name}() {{",
        f'{i1}nbkp_log "Starting sync: {slug}"',
    ]

    lines.extend(_generate_preflight_checks(sync, config, vol_paths))

    lines.extend(_generate_runtime_flags())

    if sync.destination.btrfs_snapshots.enabled:
        lines.extend(_generate_link_dest(sync, config, vol_paths))

    lines.extend(_generate_rsync_command(sync, config, vol_paths))

    if sync.destination.btrfs_snapshots.enabled:
        lines.extend(_generate_btrfs_snapshot(sync, config, vol_paths))
        btrfs_cfg = sync.destination.btrfs_snapshots
        if btrfs_cfg.max_snapshots is not None:
            lines.extend(
                _generate_btrfs_prune(
                    sync, config, btrfs_cfg.max_snapshots, vol_paths
                )
            )

    lines.append("")
    lines.append(f'{i1}nbkp_log "Completed sync: {slug}"')
    lines.append("}")
    return "\n".join(lines)


def _generate_disabled_sync(
    slug: str,
    sync: SyncConfig,
    config: Config,
    vol_paths: dict[str, str],
) -> str:
    enabled_sync = SyncConfig(
        slug=sync.slug,
        source=sync.source,
        destination=sync.destination,
        enabled=True,
        rsync_options=sync.rsync_options,
        extra_rsync_options=sync.extra_rsync_options,
        filters=sync.filters,
        filter_file=sync.filter_file,
    )
    enabled_body = _generate_sync_function(
        slug, enabled_sync, config, vol_paths
    )
    commented = "\n".join(
        f"# {line}" if line.strip() else "#"
        for line in enabled_body.split("\n")
    )
    return f"\n# : disabled — {slug}\n{commented}"


# -- Pre-flight checks ---------------------------------------------


def _generate_preflight_checks(
    sync: SyncConfig,
    config: Config,
    vol_paths: dict[str, str],
) -> list[str]:
    i1 = _SH_INDENT
    lines: list[str] = ["", f"{i1}# Pre-flight checks"]

    src_vol = config.volumes[sync.source.volume]
    dst_vol = config.volumes[sync.destination.volume]

    src_path = _vol_path(vol_paths, sync.source.volume, sync.source.subdir)
    dst_path = _vol_path(
        vol_paths, sync.destination.volume, sync.destination.subdir
    )

    # Source endpoint marker
    src_marker = f"{src_path}/.nbkp-src"
    lines.append(
        _check_line(
            src_vol,
            config,
            ["-f", src_marker],
            f"source marker {src_marker} not found",
        )
    )

    # Destination endpoint marker
    dst_marker = f"{dst_path}/.nbkp-dst"
    lines.append(
        _check_line(
            dst_vol,
            config,
            ["-f", dst_marker],
            f"destination marker {dst_marker} not found",
        )
    )

    # rsync availability on source
    lines.append(
        _which_check_line(
            src_vol,
            config,
            "rsync",
            "rsync not found on source",
        )
    )

    # rsync availability on destination
    lines.append(
        _which_check_line(
            dst_vol,
            config,
            "rsync",
            "rsync not found on destination",
        )
    )

    # Btrfs checks
    if sync.destination.btrfs_snapshots.enabled:
        lines.append(
            _which_check_line(
                dst_vol,
                config,
                "btrfs",
                "btrfs not found on destination",
            )
        )

        # latest/ directory
        latest_dir = f"{dst_path}/latest"
        lines.append(
            _check_line(
                dst_vol,
                config,
                ["-d", latest_dir],
                "destination latest/ directory not found" f" ({latest_dir})",
            )
        )

        # snapshots/ directory
        snaps_dir = f"{dst_path}/snapshots"
        lines.append(
            _check_line(
                dst_vol,
                config,
                ["-d", snaps_dir],
                "destination snapshots/ directory not found" f" ({snaps_dir})",
            )
        )

    return lines


def _check_line(
    vol: LocalVolume | RemoteVolume,
    config: Config,
    test_args: list[str],
    error_msg: str,
) -> str:
    """Generate a test ... || return 1 line."""
    i1 = _SH_INDENT
    match vol:
        case LocalVolume():
            test_cmd = "test " + " ".join(_qp(a) for a in test_args)
        case RemoteVolume():
            server = config.rsync_servers[vol.rsync_server]
            proxy = config.resolve_proxy(server)
            test_cmd = _format_remote_test(server, proxy, test_args)
    return (
        f"{i1}{test_cmd}" f' || {{ nbkp_log "ERROR: {error_msg}"; return 1; }}'
    )


def _which_check_line(
    vol: LocalVolume | RemoteVolume,
    config: Config,
    command: str,
    error_msg: str,
) -> str:
    """Generate a which/command-check line."""
    i1 = _SH_INDENT
    match vol:
        case LocalVolume():
            check = f"command -v {_sq(command)} >/dev/null 2>&1"
        case RemoteVolume():
            server = config.rsync_servers[vol.rsync_server]
            proxy = config.resolve_proxy(server)
            check = _format_remote_check(server, proxy, ["which", command])
    return f"{i1}{check}" f' || {{ nbkp_log "ERROR: {error_msg}"; return 1; }}'


# -- Runtime flags -------------------------------------------------


def _generate_runtime_flags() -> list[str]:
    i1 = _SH_INDENT
    return [
        "",
        f"{i1}# Build runtime flags",
        f'{i1}NBKP_DRY_RUN_FLAG=""',
        f'{i1}if [ "$NBKP_DRY_RUN" = true ]; then'
        ' NBKP_DRY_RUN_FLAG="--dry-run"; fi',
        f'{i1}NBKP_VERBOSE_FLAG=""',
        f'{i1}if [ "$NBKP_VERBOSE" -ge 3 ]; then' ' NBKP_VERBOSE_FLAG="-vvv"',
        f'{i1}elif [ "$NBKP_VERBOSE" -ge 2 ]; then' ' NBKP_VERBOSE_FLAG="-vv"',
        f'{i1}elif [ "$NBKP_VERBOSE" -ge 1 ]; then' ' NBKP_VERBOSE_FLAG="-v"',
        f"{i1}fi",
    ]


# -- Link-dest -----------------------------------------------------


def _generate_link_dest(
    sync: SyncConfig,
    config: Config,
    vol_paths: dict[str, str],
) -> list[str]:
    i1 = _SH_INDENT
    i2 = _SH_INDENT * 2
    dst_vol = config.volumes[sync.destination.volume]
    dest_path = _vol_path(
        vol_paths,
        sync.destination.volume,
        sync.destination.subdir,
    )
    snaps_dir = f"{dest_path}/snapshots"

    lines = [
        "",
        f"{i1}# Link-dest resolution"
        " (latest snapshot for incremental backup)",
    ]

    match dst_vol:
        case LocalVolume():
            lines.extend(
                [
                    f"{i1}NBKP_LATEST_SNAP="
                    f"$(ls {_qp(snaps_dir)}"
                    f" 2>/dev/null | sort | tail -1)",
                    f'{i1}NBKP_LINK_DEST=""',
                    f'{i1}if [ -n "$NBKP_LATEST_SNAP" ]; then',
                    f"{i2}NBKP_LINK_DEST="
                    '"--link-dest=../../snapshots/'
                    '$NBKP_LATEST_SNAP"',
                    f"{i1}fi",
                ]
            )
        case RemoteVolume():
            server = config.rsync_servers[dst_vol.rsync_server]
            proxy = config.resolve_proxy(server)
            ssh_ls = _format_remote_command_str(
                server, proxy, ["ls", snaps_dir]
            )
            lines.extend(
                [
                    f"{i1}NBKP_LATEST_SNAP="
                    f"$({ssh_ls}"
                    f" 2>/dev/null | sort | tail -1)",
                    f'{i1}NBKP_LINK_DEST=""',
                    f'{i1}if [ -n "$NBKP_LATEST_SNAP" ]; then',
                    f"{i2}NBKP_LINK_DEST="
                    '"--link-dest=../../snapshots/'
                    '$NBKP_LATEST_SNAP"',
                    f"{i1}fi",
                ]
            )

    return lines


# -- Rsync command -------------------------------------------------


def _generate_rsync_command(
    sync: SyncConfig,
    config: Config,
    vol_paths: dict[str, str],
) -> list[str]:
    i1 = _SH_INDENT
    i2 = _SH_INDENT * 2
    # Build the base command without dry-run, verbose, link-dest
    # (those are injected at runtime)
    cmd = build_rsync_command(
        sync, config, dry_run=False, link_dest=None, verbose=0
    )

    # Substitute local volume paths with vol_paths versions
    src_vol = config.volumes[sync.source.volume]
    dst_vol = config.volumes[sync.destination.volume]
    match (src_vol, dst_vol):
        case (RemoteVolume(), RemoteVolume()):
            pass  # R→R: paths are baked into inner command
        case _:
            cmd[-2] = _substitute_vol_path(
                cmd[-2], src_vol, vol_paths, sync.source.volume
            )
            cmd[-1] = _substitute_vol_path(
                cmd[-1], dst_vol, vol_paths, sync.destination.volume
            )

    lines = ["", f"{i1}# Rsync"]

    has_btrfs = sync.destination.btrfs_snapshots.enabled

    # Format as a multi-line shell command with runtime vars
    formatted = _format_shell_command(cmd, cont_indent=i2)
    runtime_vars = [
        '${NBKP_DRY_RUN_FLAG:+"$NBKP_DRY_RUN_FLAG"}',
        '${NBKP_VERBOSE_FLAG:+"$NBKP_VERBOSE_FLAG"}',
    ]
    if has_btrfs:
        runtime_vars.insert(0, '${NBKP_LINK_DEST:+"$NBKP_LINK_DEST"}')
    runtime_suffix = f" \\\n{i2}".join(runtime_vars)
    lines.append(f"{i1}{formatted} \\\n{i2}{runtime_suffix}")

    return lines


# -- Btrfs snapshot ------------------------------------------------


def _generate_btrfs_snapshot(
    sync: SyncConfig,
    config: Config,
    vol_paths: dict[str, str],
) -> list[str]:
    i1 = _SH_INDENT
    i2 = _SH_INDENT * 2
    dst_vol = config.volumes[sync.destination.volume]
    dest_path = _vol_path(
        vol_paths,
        sync.destination.volume,
        sync.destination.subdir,
    )
    latest = f"{dest_path}/latest"
    snaps_dir = f"{dest_path}/snapshots"

    lines = [
        "",
        f"{i1}# Btrfs snapshot (skip if dry-run)",
        f'{i1}if [ "$NBKP_DRY_RUN" = false ]; then',
        f"{i2}NBKP_TS=$(date -u +%Y-%m-%dT%H:%M:%S.000Z)",
    ]

    snap_cmd = [
        "btrfs",
        "subvolume",
        "snapshot",
        "-r",
        latest,
        f"{snaps_dir}/$NBKP_TS",
    ]

    match dst_vol:
        case LocalVolume():
            lines.append(
                f"{i2}" f"{_format_shell_command(snap_cmd, cont_indent=i2)}"
            )
        case RemoteVolume():
            server = config.rsync_servers[dst_vol.rsync_server]
            proxy = config.resolve_proxy(server)
            remote_cmd = _format_remote_command_str(
                server,
                proxy,
                [
                    "btrfs",
                    "subvolume",
                    "snapshot",
                    "-r",
                    latest,
                    f"{snaps_dir}/\\$NBKP_TS",
                ],
            )
            lines.append(f"{i2}{remote_cmd}")

    lines.append(f"{i1}fi")
    return lines


# -- Btrfs prune ---------------------------------------------------


def _generate_btrfs_prune(
    sync: SyncConfig,
    config: Config,
    max_snapshots: int,
    vol_paths: dict[str, str],
) -> list[str]:
    i1 = _SH_INDENT
    i2 = _SH_INDENT * 2
    i3 = _SH_INDENT * 3
    i4 = _SH_INDENT * 4
    dst_vol = config.volumes[sync.destination.volume]
    dest_path = _vol_path(
        vol_paths,
        sync.destination.volume,
        sync.destination.subdir,
    )
    snaps_dir = f"{dest_path}/snapshots"

    lines = [
        "",
        f"{i1}# Prune old snapshots (max: {max_snapshots})",
        f'{i1}if [ "$NBKP_DRY_RUN" = false ]; then',
    ]

    match dst_vol:
        case LocalVolume():
            lines.extend(
                [
                    f"{i2}NBKP_SNAPS=" f"$(ls {_qp(snaps_dir)} | sort)",
                    f"{i2}NBKP_COUNT="
                    '$(echo "$NBKP_SNAPS" | wc -l'
                    " | tr -d ' ')",
                    f"{i2}NBKP_EXCESS=" f"$((NBKP_COUNT - {max_snapshots}))",
                    f'{i2}if [ "$NBKP_EXCESS" -gt 0 ]; then',
                    f'{i3}echo "$NBKP_SNAPS"'
                    f' | head -n "$NBKP_EXCESS"'
                    f" | while IFS= read -r snap; do",
                    f'{i4}nbkp_log "Pruning' ' snapshot: $snap"',
                    f"{i4}btrfs property set"
                    f' {_qp(snaps_dir)}/"$snap"'
                    f" ro false",
                    f"{i4}btrfs subvolume delete" f' {_qp(snaps_dir)}/"$snap"',
                    f"{i3}done",
                    f"{i2}fi",
                ]
            )
        case RemoteVolume():
            server = config.rsync_servers[dst_vol.rsync_server]
            proxy = config.resolve_proxy(server)
            ssh_ls = _format_remote_command_str(
                server, proxy, ["ls", snaps_dir]
            )
            prop_cmd = _format_remote_command_str(
                server,
                proxy,
                [
                    "btrfs",
                    "property",
                    "set",
                    f"{snaps_dir}/\\$snap",
                    "ro",
                    "false",
                ],
            )
            del_cmd = _format_remote_command_str(
                server,
                proxy,
                [
                    "btrfs",
                    "subvolume",
                    "delete",
                    f"{snaps_dir}/\\$snap",
                ],
            )
            lines.extend(
                [
                    f"{i2}NBKP_SNAPS=$({ssh_ls} | sort)",
                    f"{i2}NBKP_COUNT="
                    '$(echo "$NBKP_SNAPS" | wc -l'
                    " | tr -d ' ')",
                    f"{i2}NBKP_EXCESS=" f"$((NBKP_COUNT - {max_snapshots}))",
                    f'{i2}if [ "$NBKP_EXCESS" -gt 0 ]; then',
                    f'{i3}echo "$NBKP_SNAPS"'
                    f' | head -n "$NBKP_EXCESS"'
                    f" | while IFS= read -r snap; do",
                    f'{i4}nbkp_log "Pruning' ' snapshot: $snap"',
                    f"{i4}{prop_cmd}",
                    f"{i4}{del_cmd}",
                    f"{i3}done",
                    f"{i2}fi",
                ]
            )

    lines.append(f"{i1}fi")
    return lines


# -- Invocations ---------------------------------------------------


def _generate_invocations(config: Config) -> str:
    lines = ["", "# --- Run all syncs ---"]
    for slug, sync in config.syncs.items():
        fn_name = _slug_to_fn(slug)
        if sync.enabled:
            lines.append(
                f"{fn_name}" f" || NBKP_FAILURES=$((NBKP_FAILURES + 1))"
            )
        else:
            lines.append(
                f"# {fn_name}"
                f" || NBKP_FAILURES=$((NBKP_FAILURES + 1))"
                f"  # disabled"
            )
    return "\n".join(lines)


# -- Summary -------------------------------------------------------


def _generate_summary() -> str:
    i1 = _SH_INDENT
    return (
        "\n# --- Summary ---\n"
        'if [ "$NBKP_FAILURES" -gt 0 ]; then\n'
        f'{i1}nbkp_log "$NBKP_FAILURES sync(s) failed"\n'
        f"{i1}exit 1\n"
        "fi\n"
        'nbkp_log "All syncs completed successfully"'
    )


# -- Formatting helpers --------------------------------------------


def _sq(s: str) -> str:
    """Shell-quote a string (single quotes, no variable expansion)."""
    return shlex.quote(s)


def _qp(s: str) -> str:
    """Quote a path, double-quoting if it contains shell variables.

    Falls back to :func:`_sq` when the string has no ``$``.
    Double-quoting preserves ``${VAR}`` expansion while still
    protecting against word splitting.
    """
    if "$" not in s:
        return _sq(s)
    return f'"{s}"'


def _slug_to_fn(slug: str) -> str:
    """Convert a kebab-case slug to a valid bash function name."""
    return f"sync_{slug.replace('-', '_')}"


def _format_shell_command(
    cmd: list[str],
    cont_indent: str = _SH_INDENT * 2,
) -> str:
    """Format a command list as a shell command string.

    Each element is shell-quoted and joined with backslash
    continuations for readability.  *cont_indent* controls the
    indentation of continuation lines.
    """
    parts = [_qp(arg) for arg in cmd]
    if len(parts) <= 3:
        return " ".join(parts)
    else:
        sep = f" \\\n{cont_indent}"
        return parts[0] + sep + sep.join(parts[1:])


def _format_remote_test(
    server: RsyncServer,
    proxy: RsyncServer | None,
    test_args: list[str],
) -> str:
    """Format a remote `test` command via SSH."""
    ssh_args = build_ssh_base_args(server, proxy)
    remote_cmd = "test " + " ".join(shlex.quote(a) for a in test_args)
    return " ".join(_sq(a) for a in ssh_args) + " " + _sq(remote_cmd)


def _format_remote_check(
    server: RsyncServer,
    proxy: RsyncServer | None,
    cmd: list[str],
) -> str:
    """Format a remote command check via SSH."""
    ssh_args = build_ssh_base_args(server, proxy)
    remote_cmd = " ".join(shlex.quote(a) for a in cmd)
    return (
        " ".join(_sq(a) for a in ssh_args)
        + " "
        + _sq(remote_cmd)
        + " >/dev/null 2>&1"
    )


def _format_remote_command_str(
    server: RsyncServer,
    proxy: RsyncServer | None,
    cmd: list[str],
) -> str:
    """Format a remote command via SSH as a shell string."""
    ssh_args = build_ssh_base_args(server, proxy)
    remote_cmd = " ".join(shlex.quote(a) for a in cmd)
    return " ".join(_sq(a) for a in ssh_args) + " " + _sq(remote_cmd)
